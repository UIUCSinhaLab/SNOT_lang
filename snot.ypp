%{
#include <iostream>
#include <string>
#include <map>
#include <vector>
#include <utility>
#include <cstdlib>

#include "param_storage.h"
#include "snot.yy.hpp"

 //-- I need this for atoi
using namespace std;
using namespace gsparams;

//-- Lexer prototype required by bison, aka getNextToken()
DictList *last_object;
int yylex();
int yyerror(const char *p) { cerr << "Parse error!" << endl; }
%}

//-- SYMBOL SEMANTIC VALUES -----------------------------
//-- In bison, every symbol, whether it be token or non-terminal
//-- can have a "semantic value".  A NUM token "4.35", has
//-- semantic value 4.35.  A "term" symbol representing
//-- "-3.5*2*5" has semantic value 35.0, which you get by
//-- evaluating -3.5*2*5.  An OPA symbol's semantic value
//-- is '+' or '-' depending on which symbol we actually read.
//-- Some tokens, like STOP or RP don't need a semantic value.
//-- The %union statement lists the type-and-name for each
//-- semantic value.  The %token and %type statements let you
//-- you specify semantic value types for tokens and
//-- non-terminals.
%union {
  double val;
  std::string *sym;
  gsparams::DictList *onevalue;
  std::pair< std::string , gsparams::DictList> *onepair;
  std::vector< std::pair< std::string , gsparams::DictList> > *pairlist;
};
%token <val> NUMBER
%token <sym> STRING
%type <onevalue> OBJECT ELEMENTS ARRAY
%type <onepair> PAIR
%type <onevalue> VALUE
%type <pairlist> MEMBERS
%type <sym> COMMA
%left O_BEGIN O_END A_BEGIN A_END
%left COMMA
%left COLON
%%
START: ARRAY {
  }
| OBJECT {
    last_object = $1;
  }
;
OBJECT: O_BEGIN O_END {
    $$ = new DictList();
  }
| O_BEGIN MEMBERS O_END {
    DictList *retval = new DictList();
    std::vector< std::pair< std::string , gsparams::DictList> >::iterator itr;
    for(itr = $2->begin();itr!= $2->end();++itr){
        retval->set(itr->first,itr->second);
    }
    $$=retval;
  }
;
MEMBERS: PAIR {
    std::vector< std::pair< std::string , gsparams::DictList> > *retptr = new std::vector< std::pair< std::string , gsparams::DictList> >();
    retptr->push_back(*$1);
    $$ = retptr;
  }
| PAIR COMMA MEMBERS {
    std::vector< std::pair< std::string , gsparams::DictList> > *retptr = new std::vector< std::pair< std::string , gsparams::DictList> >();
    *retptr = *$3;
    retptr->insert(retptr->begin(), *$1);
    $$ = retptr;
  }
;
PAIR: STRING COLON VALUE {
    std::pair<std::string, DictList> *retpair = new std::pair<std::string, DictList>;
    *retpair = std::make_pair(*$1, *$3);
    $$ = retpair;
  }
;
ARRAY: A_BEGIN A_END {
    DictList *retval = new DictList();
    retval->undecided_to_list_else_error();
    $$ = retval;
  }
| A_BEGIN ELEMENTS A_END {
    $$ = $2;
}
;
ELEMENTS: VALUE {
    DictList *retval = new DictList();
    retval->undecided_to_list_else_error();
    retval->push_back(*$1);
    $$ = retval;
  }
| VALUE COMMA ELEMENTS {
    DictList *retval = new DictList();
    retval->undecided_to_list_else_error();
    retval->push_back(*$1);
    for(int i = 0;i<$3->size();i++){
        retval->push_back($3->at(i));
    }
    $$ = retval;
  }
;
VALUE: NUMBER {$$=new DictList(yylval.val);}
| OBJECT {$$=$1;}
| ARRAY {$$=$1;}
;
%%
//-- FUNCTION DEFINITIONS ---------------------------------
#include <iostream>
int main()
{
    string testin=std::string("{\"tfs\":{\"A\":[1.1,1.2,1.3],\"B\":[2.1,2.2,2.3]}}");

    //yyscan_t scanner;
    //YY_BUFFER_STATE buf;
    //yylex_init(&scanner);
    //buf = yy_scan_string("replace me with the string youd like to scan", scanner);

    yy_scan_string(testin.c_str());

    if(0== yyparse()){
        cout << "success" << endl;

        DictList the_final = *last_object;

        std::vector<double> thevals;
        the_final.traverse(&thevals);
        for(int i = 0;i<thevals.size();i++){
            cout << thevals[i] << " ";
        }
        cout << endl;
    }else{
        cout << "failrure" << endl;
    }

    //yylex(scanner);
    //yy_delete_buffer(buf, scanner);
    //yylex_destroy(scanner);
    return 0;
}
